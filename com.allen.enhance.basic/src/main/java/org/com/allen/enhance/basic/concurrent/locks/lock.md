
## locks package interface

### 1.Lock接口
> Lock实现提供比使用synchronized方法和语句可以获得更广泛的锁定操作。它们允许更灵活的结构化，可能具有完全不同的属性，并且可以支持多个关联对象的Condition.
锁是用于访问多个线程控制对共享资源的访问的工具。通常，锁提供对共享资源的独占访问:一次只能有一个线程可以获得锁，并且对共享资源的访问都要求首先获得锁。但是，一些锁可以允许并发共享访问资源。如ReadWriteLock的读写锁.

### 2.Condition条件等待

> Condition出于Object监视器方法(wait notify notifyAll)成不同的对象，以得到具有多个等待集的每个对象，通过将它们与使用任意的组合效果Lock个实现。Lock替换synchronized方法和语句的使用，condition取代了对象监视器的方法使用。

> Condition实现可以提供Object监视器方法的行为和语义，例如：保证的通知顺序，或者在执行通知时不需要锁定。如果一个实现体统了这样的专门的额予以。那么实现必须记录这些语义。

> 注意:条件等待(可中断，不可中断和定时)的三种形式在一些平台上的易用性和性能等待特征可能不同。特别地，可能难以提供这些特征并保持特定的语义。例如排序保证。

### 3.ReadWriteLock读写锁

> 维护一堆关联的locks,一个用于读操作，一个用于写操作。read lock可以用于多个线程同时进行，只要没有写操作。write lock是独占锁

> 所有的ReadWriteLock实现必须保证的存储器同步效应writeLock操作也保持相对于所述关联的readLock。即：一个线程成获取读锁定将会看到在之前发布的写锁的所有更新。

> 读写锁允许访问共享数据时的并发性高于互斥锁允许的并发性。它利用了这样一个事实:一此只有一个线程可以修改共享数据，在许多情况下，任何数量的线程都可以同时读取数据。从理论上讲，通过使用读写锁允许的并发性增加将导致性能改进超时使用互斥锁。实际上，并发性的增加只能在多处理器上完全实现，然后只有在共享数据的访问模式合适的才可以。

> 读写锁是否会提高使用互斥锁的性能取决于数据被读取的频率与被修改的频率相比，读取和写入操作的持续时间以及数据的征用。

> 虽然读写锁的基本操作是直接的，但是执行必须做出许多策略决策，这可能会影响给定用户程序中读写锁定的有效性。策略如下:<br>
> 1. 在写入器释放写锁定时，确定在读取器和写入器都在等待时是否授予读取锁定或写入锁定。	
> 2. 确定在读卡器处于活动状态并且写入器正在等待时请求读取锁定的读取器是否被授予读取锁定。	
> 3. 确定锁是否可重入：一个具有写锁的线程是否可以重新获取?持有写锁可以获取读锁吗?读锁是否可以重入?	
> 4. 写入锁可以降级到读锁，而不允许插入?读锁是否协议升级为写锁，优先于其他等待读或写?	

## locks package class

### 1.AbstractOwnableSynchronizer

> 线程专有的同步器。该类提供了创建可能需要所有权概念的锁和相关同步器的基础。AbstractOwnableSynchronizer类本身不管理或使用此信息。然而，子类和工具可能会使用适当维护的值来帮助控制和监视访问并发提供诊断.		

### 2.AbstractQueuedLongSynchronizer

> 其中同步状态保持为long。此类具有完全相同的结构，属性和方法aAbstractQueuedSynchronizer与所有的状态有关的参数和结果被定义为long而非int.当创建同步器时，此类会有用.

### 3.AbstractQueuedSynchronizer

> 
