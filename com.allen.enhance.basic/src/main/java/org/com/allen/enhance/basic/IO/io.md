## Java IO模型
    这里仅仅谈论Java的IO模型，后续会详解Java中如何实现各种IO的细节.

### 1、同步还是异步
#### 1.1 同步
    每次请求必须一个个地被执行，一个请求的处理会导致整个流程的暂时等待，这些事件无法并发执行。用户线程发起IO请求后需要等待或者轮询内核IO操作完成后
    才能继续执行
#### 1.2 异步
    多个请求可以并发地执行，一个请求或者任务的执行不会导致整个流程的暂时等待。用户线程发起IO请求后任然继续执行，当内核IO操作完成后会通知用户线程或者调用注册回调函数.

### 2、阻塞还是非阻塞
#### 2.1 阻塞
    某个请求发出后，由于请求操作需要的条件不满足，请求操作一直会阻塞，不会返回，直到满足条件
#### 2.1 非阻塞
    请求发出后，若该请求需要的条件不满足，则立即返回一个标志信息告知条件不满足，不会一直等待。一般需要通过轮询请求条件是否满足来获得请求结果.
 
> 阻塞不等价于同步，而非阻塞并不等价于异步。实际上俩组概念描述的是IO模型中的不同维护.<br>
> 同步和异步重点在于多个任务执行过程中，后发起的任务是否必须等待先发起的任务执行完成之后再进行。不管先发起的任务请求是阻塞等古代完成，还是立即返回。<br>
> 阻塞和非阻塞重点在于请求的方法是否立即返回.<br>

### 2. Unix中的5种IO模型
    阻塞IO、非阻塞IO、IO多路复用(select/poll) 、信号驱动(SIGIO) 异步IO(Posix)

#### 2.1 阻塞IO
    阻塞IO分为以下俩个阶段:
        1. 等待数据就绪阶段：网络IO的情况就是等待远端的数据陆续抵达；磁盘IO的情况是等待磁盘数据从磁盘上读取到内存中
        2. 数据拷贝阶段：将内核中的内存数据拷贝到用户态的内存中。

#### 2.2 非阻塞IO
    非阻塞IO三个阶段:
        1.socket设置为NONBLOCK(非阻塞)即告知内核，当请求的IO操作无法完成时，不需要将线程暂停，而返回一个错误码(EWOULDBLOCK),这样请求不会阻塞。
        2.IO操作函数将不断测试数据是否已经准备好，如果没有准备好，继续test，直到准备好为止。真个IO请求的过程中，虽然用户线程每次IO都是立即返回，但是为了等到数据，仍然需要不断轮询，重复请求，消耗大量的CPU资源
        3.数据准备好了，从内核拷贝到用户空间。
     一般很少直接使用这种模型。而是在其他I/O模型中使用非阻塞I/O这一特性。这种方式对单个I/O请求意义不大,但给I/O多路复用提供了条件.

#### 2.3 IO多路复用(select/poll) 
    I/O多路复用会用到select或者poll函数，这两个函数也会使线程阻塞，但是和阻塞I/O所不同的是，这两个函数可以同时阻塞多个I/O操作。
    而且可以同时对多个读操作，多个写操作的I/O函数进行检测，直到有数据可读或可写时，才真正调用I/O操作函数。 
    从流程上来看，使用select函数进行I/O请求和同步阻塞模型没有太大的区别，甚至还多了添加监视Channel，以及调用select函数的额外操作，增加了额外工作。
    但是使用 select以后最大的优势是用户可以在一个线程内同时处理多个Channel的I/O请求。用户可以注册多个Channel，然后不断地调用select读取被激活的Channel，即可达到在同一个线程内同时处理多个I/O请求的目的。
    而在同步阻塞模型中，必须通过多线程的方式才能达到这个目的。 
    调用select/poll该方法由一个用户态线程负责轮询多个Channel，直到某个阶段1的数据就绪，再通知实际的用户线程执行阶段2的拷贝。 通过一个专职的用户态线程执行非阻塞I/O轮询，模拟实现了阶段一的异步化。

#### 2.4 信号驱动(SIGIO)
    首先允许socket进行信号驱动I/O，并安装一个信号处理函数，线程继续运行并不阻塞。
    当数据准备好时，线程会收到一个SIGIO信号，可以在信号处理函数中调用I/O操作函数处理数据。

#### 2.5 异步IO(Posix)
    调用aio_read 函数，告诉内核描述字，缓冲区指针，缓冲区大小，文件偏移以及通知的方式，然后立即返回。
    当内核将数据拷贝到缓冲区后，再通知应用程序。
    所以异步I/O模式下，阶段1和阶段2全部由内核完成，完成不需要用户线程的参与
    
### Java中的四种IO模型
    Unix中的五种I/O模型，除信号驱动I/O外.Java对其它四种I/O模型都有所支持.
        1.blocking I/O即是阻塞I/O
        2.而NIO即是非阻塞I/O
        3.通过NIO实现的Reactor模式即是I/O复用模型的实现
        4.通过AIO实现的Proactor模式即是异步I/O模型的实现