### 1. jvm基本概念
    JVM管理的内存分以下运行时数据区:程序计数器、Java虚拟机栈、本地方法栈、Java堆.

#### 1.1 程序计数器(Program Counter Register)
    一块较小的内存空间，它是当前线程所执行的字节码的型号指示器,字节码解释器工作时通过改变计数器的值来选择下一条需要执行的字节码指令、分支、跳转、循环等基础功能都要依赖它实现.
    每个线程都有一个独立的程序计数器，各个线程之间计数器相互不影响，因此该区域是线程私有的.
    
    当线程在执行一个Java方法时，该计数器记录的是正在执行的虚拟机字节码指令的地址，当线程在执行的是Native方法，该计数器的值为空。另外，该内存区域是唯一一个在Java虚拟机规范中没有OOM的区域/
    
#### 1.2 Java虚拟机栈(Java Virtual Machine Stacks)
    该区域也是线程私有的，它的生命周期也与线程相同。虚拟机栈描述的是Java方法执行的内存模型:每个方法被执行的时候都会同时创建一个栈帧，栈它是用于支持虚拟机进行方法调用和方法执行的数据结构.
    对于执行引擎来讲，活动线程中，只有栈顶的栈帧是有效的，称为当前栈帧，这个栈帧所关联的方法称为当前方法，执行引擎所允许的所有字节码指令都只针对当前栈帧进行操作。栈帧用于存储局部变量表、、
    操作数栈、动态链路、方法返回地址和一些额外的附加信息.因此在编译程序代码时，栈帧进行操作。栈帧用于存储局部变量表、操作数栈、动态连接、方法返回地址和一些额外的附加信息。在编译程序代码时，栈帧中需要多大的局部变量表、多深的操作数栈都已经完全确定了，并且写入了方法表的Code属性之中。
    因此，一个栈帧需要分配多少内存，不会受到程序运行期变量数据的影响，而仅仅取决于具体的虚拟机实现。

#### 1.3 本地方法栈(Native Method Stacks)
    该区域的与虚拟机栈的功能类似，只是虚拟机栈为虚拟机执行Java方法服务，而本地方法栈则为使用到的本地操作系统(Native)方法服务.    
    
#### 1.4 Java堆(Java Heap)
    Java Heap是Java虚拟机所管理的内存中最大的一块，它是所有线程共享的一块内存区域。几乎所有的对象实例和数组都在这里分配。Java Heap也是垃圾回收器主要管理的区域。
    
#### 1.5 方法区域(Method Area)  
    方法区是哥哥线程共享的内存区域，它用于村粗已经被虚拟机加载的类信息、常量、静态变量、即时比阿尼器编译后的代码等数据.方法区域也称为永久代.

#### 1.6 内存泄露和内存溢出
    内存泄露是指分配的出去的内存没有被回收回来，由于时区了对该内存区域的控制，因而造成资源的浪费。

#### 1.7 堆里分配的 Eden surival from to ，老年代
        堆 = （Eden + 2Sur）年轻代 + 老年代

#### 1.8 GC的俩中判定方法： 引用计数 和 引用链
    引用计数：让每个被管理的对象与一个引用计数器相互管理，计数器记录该对象当前被引用的次数，每创建一个新的引用指向改对象时其计数器+1，每当引用失效的时候-1.当计数器的值降到0的时候，认为对象已经亡了。
    

### 2. JVM类加载机制
    虚拟机把描述类的数据从Class文件加载到内存，并对数据进行校验、转换解析和初始化，最终形成可以被Java虚拟机直接使用的Java类型，这就是虚拟机的类加载机制。
    类从被加载到虚拟机雷村中开始、到卸载内存为止，生命周期如下：
        加载(Loading)
        验证(Verification)
        准备(Preparation)
        解析(Resolution)
        初始化(Initialzation)
        使用(Using)
        卸载(unloading)

### 3. Java内存区域与内存溢出


### 4. 垃圾回收算法
    1.引用计数算法：缺点无法处理循环引用。
    2.标记-清除算法：标记所有从根节点开始的可达对象，缺点：造成内存不连续。不连续的内存空间的工作效率低于连续的内存空间，不容易分配内存
    3.复制算法：将内存分为两块，每次将正在使用的内存中存活对象复制到未使用的内存中，之后清除正在使用的内存块。算法效率高，但是代价是系统内存折半。适用于新生代(存活对象少，垃圾对象多)
    4.标记－压缩算法：标记－清除的改进，清除未标记的对象时还将所有的存活对象压缩到内存的一端，之后，清理边界所有空间既避免碎片产生，又不需要两块同样大小的内存快，性价比高。适用于老年代。
    5.分代
    6.G1
    7.ZGC